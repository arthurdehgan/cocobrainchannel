#N canvas 542 43 558 549 10;
#X obj 2 229 cnv 3 550 3 empty empty inlets 8 12 0 13 -228856 -1 0
;
#X obj 2 347 cnv 3 550 3 empty empty outlets 8 12 0 13 -228856 -1 0
;
#X obj 82 236 cnv 17 3 84 empty empty 0 5 9 0 16 -228856 -162280 0
;
#X obj 82 355 cnv 17 3 17 empty empty 0 5 9 0 16 -228856 -162280 0
;
#X obj 82 325 cnv 17 3 17 empty empty 1 5 9 0 16 -228856 -162280 0
;
#X obj 82 376 cnv 17 3 17 empty empty 1 5 9 0 16 -228856 -162280 0
;
#X obj 199 205 nbx 2 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X obj 2 4 cnv 15 553 42 empty empty empty 20 12 0 14 -233017 -66577
0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 554 42 1;
#X restore 2 3 graph;
#X obj 305 4 cnv 15 250 40 empty empty empty 12 13 0 18 -128992 -233080
0;
#X obj 199 181 cyclone/zl len;
#X text 119 249 anything;
#X text 91 263 mode <symbol>;
#X text 178 249 - one or more element messages to be processed;
#X text 119 324 anything;
#X text 119 375 anything;
#X text 119 354 anything;
#X text 91 306 zlmaxsize <f>;
#X obj 2 399 cnv 3 550 3 empty empty arguments 8 12 0 13 -228856 -1
0;
#X obj 2 522 cnv 15 552 21 empty empty empty 20 12 0 14 -233017 -33289
0;
#X text 170 421 -;
#X text 170 405 -;
#X text 112 405 1) float;
#X text 112 421 1) symbol;
#X obj 2 495 cnv 3 550 3 empty empty attributes 8 12 0 13 -228856 -1
0;
#N canvas 0 22 450 300 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1;
#X restore 304 3 graph;
#X msg 242 128 beep 1 2 3 4;
#X text 143 234 bang;
#X text 126 291 zlclear;
#N canvas 638 150 649 574 examples 1;
#X obj 59 209 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 146 331 nbx 4 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 28 29 You can set the size of the list with a first optional
float argument. If you don't \, then the first argument is a symbol
that specifies the mode type \, and the maximum size is the default:
256 elements., f 54;
#X text 28 160 The maximum size is also set via the 'zlmaxsize' attribute
or message (and it can be up to 32767)., f 54;
#X obj 28 6 cyclone/comment 251 14 monaco ? 0 0 0 0 Arguments: mode
and list size:;
#X obj 397 53 cyclone/comment 185 14 monaco ? 0 0 0 0 Modes:;
#X obj 142 472 cyclone/comment 185 14 monaco ? 0 0 0 0 Inconsistency:
;
#X text 143 497 In Max \, the zl family of objects can be instantiated
with the mode after a dot \, such as [zl.group]. But this is not possible
in Pd \, where the mode needs to be called as an argument after a space.
, f 66;
#X text 28 81 The mode argument is obrigatory and this means there
is no default mode. If you don't set a mode as an argument \, you have
to set it via the mode message., f 54;
#N canvas 740 59 394 428 ecils 0;
#X obj 22 8 comment 185 14 monaco ? 0 0 0 0 Mode: ecils;
#X obj 235 284 nbx 3 14 0 100 0 0 empty empty empty 0 -8 0 10 -228856
-1 -1 0 256;
#X text 275 282 split point;
#X text 32 386 See also 'slice' mode;
#X obj 59 271 bng 20 250 50 0 empty empty empty 17 7 0 10 -228856 -1
-1;
#X obj 112 345 print ecils_Left;
#X obj 235 346 print ecils_Right;
#X msg 122 275 a b c d e f g h;
#X msg 112 250 1 2 3 4 5 6 7;
#X msg 90 223 mode ecils 4;
#X text 21 35 'ecils' is 'slice' backwards \, so it slices a list in
reverse order. You can set the split point with an argument or with
a float input into the right inlet \, but also when you set the mode
with the mode message. The default point is '0' \, which means no slicing.
;
#X obj 112 308 cyclone/zl ecils 3, f 21;
#X text 24 161 A bang performs the operation in the last received list.
;
#X text 22 111 If you slice at 'n' \, the left outlet spits the last
'n' elements and the right outlet sends the first sliced elements.
;
#X text 172 222 <= sets mode and argument;
#X msg 56 196 zlclear;
#X connect 1 0 11 1;
#X connect 4 0 11 0;
#X connect 7 0 11 0;
#X connect 8 0 11 0;
#X connect 9 0 11 0;
#X connect 11 0 5 0;
#X connect 11 1 6 0;
#X connect 15 0 11 0;
#X restore 430 154 pd ecils;
#N canvas 893 197 393 459 group 0;
#X obj 274 271 bng 15 250 50 0 empty empty empty 17 7 0 10 -228856
-1 -1;
#X obj 17 10 comment 185 14 monaco ? 0 0 0 0 Mode: group;
#X obj 95 342 bng 20 250 50 0 empty empty empty 17 7 0 10 -228856 -1
-1;
#X obj 267 365 nbx 3 14 0 100 0 0 empty empty empty 0 -8 0 10 -228856
-1 -1 0 256;
#X text 307 363 group size;
#X obj 156 388 cyclone/zl group 10;
#X floatatom 191 342 5 0 0 0 - - -, f 5;
#X text 31 344 remainder;
#X obj 274 298 cyclone/uzi 24;
#X text 16 220 The right outlet is inactive.;
#X obj 156 415 print zl_group;
#X msg 156 259 mode group 4;
#X text 34 258 set mode & argument;
#X text 14 117 The input can have one or more elements \, when the
grouped elements reach the group size \, the grouped list is sent out
the left outlet. The remaining items are stored for next group.;
#X text 15 176 A bang message causes it to spit (and clear from the
memory) the remaining stored elements (at the set group size).;
#X msg 98 289 zlclear;
#X text 15 36 The group mode aggroups 'n' elements into a list \, where
'n' cannot be higher than the maximum zl size. You can set 'n' (the
group size) with an argument or with a float input into the right inlet
\, but also when you set the mode with the mode message. The default
group size is 0 \, which means nothing gets grouped and output.;
#X msg 178 316 list g h i j k;
#X msg 166 293 a b c d e f;
#X connect 0 0 8 0;
#X connect 2 0 5 0;
#X connect 3 0 5 1;
#X connect 5 0 10 0;
#X connect 6 0 5 0;
#X connect 8 2 5 0;
#X connect 11 0 5 0;
#X connect 15 0 5 0;
#X connect 17 0 5 0;
#X connect 18 0 5 0;
#X restore 430 196 pd group;
#N canvas 753 249 463 451 iter 0;
#X msg 169 287 1 2 3 4 5 6;
#X msg 151 259 mode iter 4;
#X obj 151 393 print iter;
#X obj 24 18 comment 185 14 monaco ? 0 0 0 0 Mode: iter;
#X text 23 49 The iter mode breaks an input list in to sucessive lists
of a given size. If an input list is smaller than the iter size \,
the lista is output anyway - if the last bit of the broken list is
of a size smaller than the iter size \, it is also output.;
#X obj 111 290 bng 18 250 50 0 empty empty empty 17 7 0 10 -228856
-1 -1;
#X floatatom 194 336 5 0 0 0 - - -, f 5;
#X obj 250 343 nbx 3 14 1 100 0 0 empty empty empty 0 -8 0 10 -228856
-1 -1 1 256;
#X text 290 341 iter size;
#X text 23 121 The iter size can be set with an argument or with a
float input into the right inlet \, but also when you set the mode
with the mode message. The minimum iter size is 1 and the default is
'0' \, which means nothing happens.;
#X text 24 202 The right outlet is inactive.;
#X msg 180 312 one two three four five six;
#X obj 151 368 cyclone/zl iter 1;
#X text 24 182 A bang performs the operation in the last received list.
;
#X text 229 258 <= sets mode and argument;
#X msg 127 236 zlclear;
#X connect 0 0 12 0;
#X connect 1 0 12 0;
#X connect 5 0 12 0;
#X connect 6 0 12 0;
#X connect 7 0 12 1;
#X connect 11 0 12 0;
#X connect 12 0 2 0;
#X connect 15 0 12 0;
#X restore 430 237 pd iter;
#N canvas 919 115 408 292 join 0;
#X obj 17 13 comment 185 14 monaco ? 0 0 0 0 Mode: join;
#X obj 141 248 print zl_join;
#X obj 77 159 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X text 25 158 resends;
#X msg 122 147 mode join a b;
#X text 16 44 The join mode joins two lists sent to each inlet (things
in list 2 that are in list 1 are duplicated). A bang resends the last
output or outputs a new list if the right inlet received something
new. Subsequent arguments initialize the right list. The right outlet
is inactive.;
#X obj 141 215 cyclone/zl join 4 5 6;
#X msg 264 176 x y z;
#X msg 141 175 1 2 3;
#X text 208 146 <= sets mode and arguments;
#X msg 97 121 zlclear;
#X connect 2 0 6 0;
#X connect 4 0 6 0;
#X connect 6 0 1 0;
#X connect 7 0 6 1;
#X connect 8 0 6 0;
#X connect 10 0 6 0;
#X restore 430 258 pd join;
#N canvas 781 151 405 407 len 0;
#X msg 155 191 this produces 3;
#X msg 166 223 and this should be five;
#X obj 131 290 cyclone/zl len;
#X msg 131 160 list two elements;
#X obj 131 326 nbx 4 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X obj 72 226 bng 18 250 50 0 empty empty empty 17 7 0 10 -228856 -1
-1;
#X obj 131 354 print zl_len;
#X obj 25 17 comment 185 14 monaco ? 0 0 0 0 Mode: len;
#X msg 106 131 mode len;
#X msg 176 256 1 2 3 4 5 6 7 8 9 10 11 12 13 14;
#X text 164 130 <= sets mode;
#X text 21 226 resends;
#X text 24 47 The len mode outputs how many elements a lista has. A
bang resends the last output. This mode has no arguments. The right
inlet/outlet are inactive.;
#X msg 84 107 zlclear;
#X connect 0 0 2 0;
#X connect 1 0 2 0;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 6 0;
#X connect 5 0 2 0;
#X connect 8 0 2 0;
#X connect 9 0 2 0;
#X connect 13 0 2 0;
#X restore 430 301 pd len;
#N canvas 573 172 789 398 mth 0;
#X obj 70 266 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 451 220 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 25 8 comment 185 14 monaco ? 0 0 0 0 Mode: mth;
#X msg 117 259 1 2 3 4 5 6 7 8 9 10;
#X obj 210 293 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X obj 72 358 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 25 162 A bang performs the operation in the last received list.
;
#X msg 504 200 1 2 3 4 5 6 7 8 9 10;
#X obj 440 301 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 421 72 The element that replaces the mth element in the right
outlet is set as the 2nd argument. This is optional \, no second argument
(the default) does not replace the mth element by anything.;
#X obj 595 300 print replaced_mth;
#X text 638 229 mth / replacement;
#X text 250 292 mth;
#X obj 210 355 print not_the_mth;
#X obj 117 321 cyclone/zl mth 3;
#X obj 484 264 cyclone/zl mth 2 hi;
#X msg 484 172 mode mth 3 hello;
#X msg 595 229 6 bye;
#X text 24 36 The mode mth is the same as mth but starts counting from
0 instead. It outputs the mth element of a message through the left
outlet. The right outlet outputs the remaining elements \, but the
output can also replace the mth element by another.;
#X text 24 100 The mth element is set as the 1st argument. The 1st
element is treated as "0 '(the default). If you set the mth to a number
greater than the input list \, all the elements are sent to the right
outlet \, the same happens for negative mth values.;
#X msg 103 232 mode mth 5;
#X msg 77 205 zlclear;
#X msg 462 145 zlclear;
#X obj 117 355 print zl_mth;
#X obj 484 300 print zl_mth;
#X connect 0 0 14 0;
#X connect 1 0 15 0;
#X connect 3 0 14 0;
#X connect 4 0 14 1;
#X connect 7 0 15 0;
#X connect 14 0 5 0;
#X connect 14 0 23 0;
#X connect 14 1 13 0;
#X connect 15 0 8 0;
#X connect 15 0 24 0;
#X connect 15 1 10 0;
#X connect 16 0 15 0;
#X connect 17 0 15 1;
#X connect 20 0 14 0;
#X connect 21 0 14 0;
#X connect 22 0 15 0;
#X restore 430 368 pd mth;
#N canvas 426 244 812 412 nth 0;
#X obj 75 274 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 466 197 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 25 8 comment 185 14 monaco ? 0 0 0 0 Mode: nth;
#X msg 127 266 1 2 3 4 5 6 7 8 9 10;
#X obj 220 300 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 260 299 nth;
#X obj 82 365 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X obj 127 328 cyclone/zl nth 3;
#X text 25 165 A bang performs the operation in the last received list.
;
#X obj 220 362 print not_the_nth;
#X obj 615 280 print replaced_nth;
#X obj 504 244 cyclone/zl nth 2 hi;
#X msg 524 180 1 2 3 4 5 6 7 8 9 10;
#X text 421 55 The element that replaces the nth element in the right
outlet is set as the 2nd argument. This is optional \, no second argument
(the defaukt) does not replace the nth element by anything.;
#X obj 460 281 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 654 209 nth / replacement;
#X msg 504 152 mode nth 3 hello;
#X text 24 36 The mode nth is the same as mth but starts counting from
1 instead. It outputs the nth element of a message through the left
outlet. The right outlet outputs the remaining elements \, but the
output can also replace the nth element by another., f 61;
#X text 23 103 The nth element is set as the 1st argument. The 1st
element is treated as "1" \, if you set it as 0 (the default) or to
a number greater than the input list \, all the elements are sent to
the right outlet and nothing is sent via the left outlet., f 61;
#X text 185 234 <= sets mode and arguments;
#X msg 109 235 mode nth 8;
#X msg 615 209 0 bye;
#X msg 86 207 zlclear;
#X msg 482 127 zlclear;
#X obj 504 280 print zl_nth;
#X obj 127 362 print zl_nth;
#X connect 0 0 7 0;
#X connect 1 0 11 0;
#X connect 3 0 7 0;
#X connect 4 0 7 1;
#X connect 7 0 6 0;
#X connect 7 0 25 0;
#X connect 7 1 9 0;
#X connect 11 0 14 0;
#X connect 11 0 24 0;
#X connect 11 1 10 0;
#X connect 12 0 11 0;
#X connect 16 0 11 0;
#X connect 20 0 7 0;
#X connect 21 0 11 1;
#X connect 22 0 7 0;
#X connect 23 0 11 0;
#X restore 430 389 pd nth;
#N canvas 786 294 430 326 reg 0;
#X obj 69 286 print reg;
#X obj 111 222 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X msg 306 192 this is stored;
#X msg 91 193 this is stored and sent;
#X msg 69 161 1 2 3 4;
#X msg 287 161 5 6 7 8;
#X text 136 224 <= outputs stored list;
#X msg 52 136 mode reg one two;
#X text 159 135 <= sets mode and arguments;
#X text 30 44 The reg mode stores lists. The initially stored list
is set as an argument and changed in the right inlet. The left inlet
stores and outputs the list. A bang sends the last stored list. The
right outlet is inactive.;
#X obj 33 17 comment 185 14 monaco ? 0 0 0 0 Mode: reg;
#X msg 30 114 zlclear;
#X obj 69 251 cyclone/zl reg initially stored elements;
#X connect 1 0 12 0;
#X connect 2 0 12 1;
#X connect 3 0 12 0;
#X connect 4 0 12 0;
#X connect 5 0 12 1;
#X connect 7 0 12 0;
#X connect 11 0 12 0;
#X connect 12 0 0 0;
#X restore 513 112 pd reg;
#N canvas 865 220 418 288 rev 0;
#X msg 137 155 way this something means this;
#X obj 26 7 comment 185 14 monaco ? 0 0 0 0 Mode: rev;
#X obj 80 159 bng 18 250 50 0 empty empty empty 17 7 0 10 -228856 -1
-1;
#X text 25 38 The rev mode reverses the elements of a list. A bang
resends the last output. This mode has no arguments. The right inlet/outlet
are inactive.;
#X msg 148 182 1 2 3 4 5 6 7 8 9 10;
#X obj 117 252 print zl_rev;
#X msg 117 120 mode rev;
#X text 178 119 <= sets mode;
#X obj 117 217 cyclone/zl rev;
#X msg 94 91 zlclear;
#X connect 0 0 8 0;
#X connect 2 0 8 0;
#X connect 4 0 8 0;
#X connect 6 0 8 0;
#X connect 8 0 5 0;
#X connect 9 0 8 0;
#X restore 513 133 pd rev;
#N canvas 842 204 399 436 rot 0;
#X msg 123 268 sometimes my grammar is all messed up;
#X obj 103 356 cyclone/zl rot 3;
#X obj 196 331 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X obj 17 7 comment 185 14 monaco ? 0 0 0 0 Mode: rot;
#X obj 64 311 bng 18 250 50 0 empty empty empty 17 7 0 10 -228856 -1
-1;
#X text 18 156 A bang performs the operation in the last received list.
;
#X text 18 176 The right outlet is inactive.;
#X obj 103 395 print zl_rot;
#X text 17 35 The mode rot does rotate a list. If the rotation point
is a positive number 'n' \, the list is shifted to the right by 'n'
positions \, and the last 'n' elements are placed at the list start.
If 'n' is negative \, the rotation happens at the other direction.
;
#X text 18 99 You can set the rotation point with an argument or with
a float input into the right inlet \, but also when you set the mode
with the mode message. The default point is '0' \, which means no rotation.
;
#X msg 147 298 1 2 3 4 5 6 7 8 9 10 11 12;
#X msg 103 239 mode rot -3;
#X text 180 239 <= sets mode and argument;
#X msg 78 212 zlclear;
#X connect 0 0 1 0;
#X connect 1 0 7 0;
#X connect 2 0 1 1;
#X connect 4 0 1 0;
#X connect 10 0 1 0;
#X connect 11 0 1 0;
#X connect 13 0 1 0;
#X restore 513 154 pd rot;
#N canvas 949 241 424 357 sect 0;
#X obj 52 220 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 229 305 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X text 244 321 no common elements;
#X text 250 307 bang if there are;
#X obj 88 306 print zl_sect;
#X msg 229 217 1 5 10 15 20;
#X obj 20 7 comment 185 14 monaco ? 0 0 0 0 Mode: sect;
#X msg 88 191 mode sect 3 6 9;
#X text 18 35 The mode sect outputs the elements of an input list that
are in common to another list (set as an argument or via the right
inlet). The default is an empty list.;
#X text 19 82 The right outlet outputs a bang if there are no matching
elements.;
#X text 19 117 A bang performs the operation in the last received list
into the left inlet.;
#X msg 96 246 1 2 3 4 5 6 7 8 9 10;
#X msg 249 243 0 100 1000;
#X obj 88 274 cyclone/zl sect 1 10 100;
#X text 188 191 <= sets mode and arguments;
#X msg 70 165 zlclear;
#X connect 0 0 13 0;
#X connect 5 0 13 1;
#X connect 7 0 13 0;
#X connect 11 0 13 0;
#X connect 12 0 13 1;
#X connect 13 0 4 0;
#X connect 13 1 1 0;
#X connect 15 0 13 0;
#X restore 513 196 pd sect;
#N canvas 824 23 415 398 slice 0;
#X obj 22 8 comment 185 14 monaco ? 0 0 0 0 Mode: slice;
#X obj 235 264 nbx 3 14 0 100 0 0 empty empty empty 0 -8 0 10 -228856
-1 -1 0 256;
#X text 275 262 split point;
#X obj 55 247 bng 20 250 50 0 empty empty empty 17 7 0 10 -228856 -1
-1;
#X msg 122 255 a b c d e f g h;
#X msg 112 230 1 2 3 4 5 6 7;
#X text 24 141 A bang performs the operation in the last received list.
;
#X text 32 366 See also 'ecils' mode;
#X text 21 35 The slice mode slices a list. You can set the split point
with an argument or with a float input into the right inlet \, but
also when you set the mode with the mode message. The default point
is '0' \, which means no slicing.;
#X msg 91 203 mode slice 4;
#X obj 112 288 cyclone/zl slice 3, f 21;
#X obj 112 325 print slice_Left;
#X obj 235 326 print slice_Right;
#X text 22 101 If you slice at 'n' \, the left outlet spits the first
'n' elements and the right outlet sends the remaining elements.;
#X text 175 203 <= sets mode and argument;
#X msg 63 176 zlclear;
#X connect 1 0 10 1;
#X connect 3 0 10 0;
#X connect 4 0 10 0;
#X connect 5 0 10 0;
#X connect 9 0 10 0;
#X connect 10 0 11 0;
#X connect 10 1 12 0;
#X connect 15 0 10 0;
#X restore 513 216 pd slice;
#N canvas 889 66 405 334 sub 0;
#X obj 69 188 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X msg 210 220 11;
#X msg 246 220 7 8 9;
#X obj 20 14 comment 185 14 monaco ? 0 0 0 0 Mode: sub;
#X msg 175 220 1;
#X obj 210 285 print occurances;
#X obj 111 285 print position;
#X text 18 42 the sub mode searches for occurances of the element(s)
of the second list to the first list and outputs the number of occurances
in the right outlet and the position of such occurances in the left
outlet. If no occurance is found \, the right outlet outputs 0 and
nothing is output on the left outlet. Subsequent arguments initialize
the right list.;
#X msg 111 161 mode sub 5;
#X text 182 161 <= sets mode and arguments;
#X msg 125 189 1 2 3 7 8 9 10 4 5 6 7 8 9 10;
#X obj 111 251 cyclone/zl sub 10;
#X msg 91 134 zlclear;
#X connect 0 0 11 0;
#X connect 1 0 11 1;
#X connect 2 0 11 1;
#X connect 4 0 11 1;
#X connect 8 0 11 0;
#X connect 10 0 11 0;
#X connect 11 0 6 0;
#X connect 11 1 5 0;
#X connect 12 0 11 0;
#X restore 513 301 pd sub;
#N canvas 861 239 405 268 union 0;
#X obj 65 153 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: union;
#X obj 108 227 print zl_union;
#X text 21 39 union the stuff in two lists (but does not duplicate
things in list 2 that are in list 1). Subsequent arguments initialize
the right list. The right outlet is inactive.;
#X msg 237 160 6.5 4 2.3 2 2 8 hi;
#X msg 108 127 mode union a b;
#X text 204 126 <= sets mode and arguments;
#X obj 108 198 cyclone/zl union 10 20;
#X msg 83 96 zlclear;
#X msg 122 159 2.3 7 6.5 hi;
#X connect 0 0 7 0;
#X connect 4 0 7 1;
#X connect 5 0 7 0;
#X connect 7 0 2 0;
#X connect 8 0 7 0;
#X connect 9 0 7 0;
#X restore 514 390 pd union;
#X text 198 205 set to default;
#X obj 146 355 print length;
#X msg 172 249 zlmaxsize \$1;
#X msg 172 205 256;
#X msg 186 227 512;
#X text 28 385 In the above example \, the objects are initialized
to a size of 512 but can be resized to the default (256). Note that
the group message can't group 512 elements if its size is 256 \, hence
it groups two 256 elements message., f 54;
#X text 212 227 back to 512;
#X obj 59 236 cyclone/uzi 512;
#X obj 146 276 cyclone/zl 512 group 512;
#X obj 146 304 cyclone/zl len @zlmaxsize 512;
#N canvas 889 66 405 380 sort 0;
#X obj 69 218 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 14 comment 185 14 monaco ? 0 0 0 0 Mode: sort;
#X text 192 191 <= sets mode and arguments;
#X msg 91 164 zlclear;
#X msg 233 250 1;
#X msg 198 250 -1;
#X msg 111 191 mode sort -1;
#X obj 111 281 cyclone/zl sort;
#X obj 111 315 print sorted;
#X obj 198 315 print indexes;
#X text 17 42 The sort mode sorts the elements of a list. An additional
argument specifies the order: "-1" sorts in descending order \, and
any other value sorts in ascending order (the default is "0"/ascending).
This vis also specified in the right inlet.;
#X text 264 250 <= order;
#X text 18 104 The left outlet outputs the sorted list \, and the right
outlet outputs the sorted indexes., f 57;
#X msg 125 220 10 3 b 4 6 a 9 d 2 c 1 5 0 8 7;
#X connect 0 0 7 0;
#X connect 3 0 7 0;
#X connect 4 0 7 1;
#X connect 5 0 7 1;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 7 1 9 0;
#X connect 13 0 7 0;
#X restore 513 237 pd sort;
#X text 28 121 Check details about each mode in the subpatches on the
right. The modes introduced in the Max5+ versions are not implemented
yet., f 54;
#N canvas 861 239 403 306 change 0;
#X obj 98 150 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: change;
#X msg 116 93 zlclear;
#X msg 155 156 1 2 2 5.5 7 5 7 7 7;
#X obj 141 270 print zl_change;
#X obj 240 245 tgl 15 0 empty empty empty 17 7 0 10 -228856 -1 -1 0
1;
#X obj 141 215 cyclone/zl change;
#X msg 178 186 a b e c e;
#X obj 240 269 print changed;
#X text 21 41 The change mode filters out list repetitions. The right
outlet sends "1" when there's a new list and "0" when it is repeated.
;
#X msg 141 124 mode change;
#X text 217 124 <= sets mode;
#X connect 0 0 6 0;
#X connect 2 0 6 0;
#X connect 3 0 6 0;
#X connect 5 0 8 0;
#X connect 6 0 4 0;
#X connect 6 1 5 0;
#X connect 7 0 6 0;
#X connect 10 0 6 0;
#X restore 429 91 pd change;
#N canvas 861 239 403 306 compare 0;
#X obj 55 175 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: compare;
#X msg 73 108 zlclear;
#X obj 98 237 cyclone/zl compare a b c;
#X obj 239 269 print indexes;
#X obj 98 269 print zl_compare;
#X msg 112 174 a b c;
#X msg 255 214 a b c d;
#X msg 123 202 a b c d;
#X msg 239 189 a b c;
#X msg 98 139 mode compare a b c;
#X text 220 138 <= sets mode and arguments;
#X text 21 41 The compare mode compares two lists and sends "1" if
it is the same or "0" if it is not. In the case on non equal lists
\, the right output sends the number of non equal indexes.;
#X connect 0 0 3 0;
#X connect 2 0 3 0;
#X connect 3 0 5 0;
#X connect 3 1 4 0;
#X connect 6 0 3 0;
#X connect 7 0 3 1;
#X connect 8 0 3 0;
#X connect 9 0 3 1;
#X connect 10 0 3 0;
#X restore 429 112 pd compare;
#N canvas 861 239 390 258 delace 0;
#X obj 78 137 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 21 12 comment 185 14 monaco ? 0 0 0 0 Mode: delace;
#X msg 96 80 zlclear;
#X obj 102 211 print zl_delace-A;
#X obj 219 211 print zl_delace-B;
#X msg 135 143 A 1 B 2 C 3;
#X msg 121 111 mode delace;
#X text 197 111 <= sets mode;
#X text 22 39 delace de-interleaves a list into two lists.;
#X obj 120 182 cyclone/zl delace;
#X connect 0 0 9 0;
#X connect 2 0 9 0;
#X connect 5 0 9 0;
#X connect 6 0 9 0;
#X connect 9 0 3 0;
#X connect 9 1 4 0;
#X restore 429 133 pd delace;
#N canvas 713 142 405 289 filter 0;
#X obj 63 176 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: filter;
#X text 244 139 <= sets mode and arguments, f 14;
#X msg 81 109 zlclear;
#X obj 106 221 cyclone/zl filter toto titi;
#X msg 265 191 truc 1;
#X obj 106 250 print zl_filter;
#X msg 130 193 a b toto c titi;
#X obj 265 250 print indexes;
#X text 21 39 filter removes items in a list \, the items to filter
are specified as the arguments or the right input. The right outlet
ouputs the unfiltered and output indexes.;
#X msg 106 139 mode filter toto titi;
#X msg 120 169 truc machin 2 3.4 1;
#X connect 0 0 4 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 8 0;
#X connect 5 0 4 1;
#X connect 7 0 4 0;
#X connect 10 0 4 0;
#X connect 11 0 4 0;
#X restore 430 175 pd filter;
#N canvas 783 223 405 268 lace 0;
#X obj 65 153 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: lace;
#X msg 83 96 zlclear;
#X text 223 126 <= sets mode;
#X msg 108 127 mode lace 1 2 3 4;
#X msg 122 159 A B C D;
#X obj 108 227 print zl_lace;
#X msg 243 167 10 20 30 40;
#X obj 108 198 cyclone/zl lace x w y z;
#X text 21 39 lace interleaves two lists. Subsequent arguments initialize
the right list. The right outlet is inactive.;
#X connect 0 0 8 0;
#X connect 2 0 8 0;
#X connect 4 0 8 0;
#X connect 5 0 8 0;
#X connect 7 0 8 1;
#X connect 8 0 6 0;
#X restore 430 279 pd lace;
#N canvas 827 198 405 268 lookup 0;
#X obj 65 153 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: lookup;
#X obj 108 227 print zl_union;
#X text 224 127 <= sets mode and arguments;
#X msg 83 96 zlclear;
#X msg 297 170 a b 1 4;
#X msg 132 169 0 2;
#X msg 108 128 mode lookup x y z;
#X text 21 39 lookup outputs the nth elements in a list. The arguments
or right input sets the list to lookup and the left input sets the
nth elements.;
#X obj 108 199 cyclone/zl lookup toto titi tutu;
#X connect 0 0 9 0;
#X connect 4 0 9 0;
#X connect 5 0 9 1;
#X connect 6 0 9 0;
#X connect 7 0 9 0;
#X connect 9 0 2 0;
#X restore 430 324 pd lookup;
#N canvas 861 239 405 301 median 0;
#X obj 111 145 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: median;
#X msg 129 88 zlclear;
#X obj 154 200 cyclone/zl median;
#X msg 168 151 1 2 2 5.5 7 5 7 7 7;
#X msg 188 175 6 1 3;
#X msg 154 119 mode median;
#X text 232 118 <= sets mode;
#X obj 154 229 nbx 4 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 43 47 median outputs the median of a list of numbers;
#X obj 154 256 print zl_median;
#X connect 0 0 3 0;
#X connect 2 0 3 0;
#X connect 3 0 8 0;
#X connect 4 0 3 0;
#X connect 5 0 3 0;
#X connect 6 0 3 0;
#X connect 8 0 10 0;
#X restore 430 346 pd median;
#N canvas 861 239 441 293 scramble 0;
#X obj 34 165 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: scramble;
#X msg 248 173 6.5 4 2.3 2 2 8 hi;
#X text 227 138 <= sets mode and arguments;
#X msg 52 108 zlclear;
#X msg 91 171 1 2 3.4 toto titi tutu;
#X obj 77 239 print zl_scramble;
#X obj 248 239 print indexes;
#X msg 77 139 mode scramble 1 2 3 4 5;
#X obj 77 210 cyclone/zl scramble 1 2 3 4 5;
#X text 21 39 scramble scrambles the order of a list. The right input
and arguments sets the list. The right outlet outputs the scrambled
indexes.;
#X connect 0 0 9 0;
#X connect 2 0 9 1;
#X connect 4 0 9 0;
#X connect 5 0 9 0;
#X connect 8 0 9 0;
#X connect 9 0 6 0;
#X connect 9 1 7 0;
#X restore 513 175 pd scramble;
#N canvas 601 172 442 332 queue 0;
#X obj 117 181 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 26 12 comment 185 14 monaco ? 0 0 0 0 Mode: queue;
#X msg 124 120 zlclear;
#X obj 164 236 cyclone/zl queue;
#X msg 164 174 1 a 2 b 3 c;
#X obj 257 272 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 298 272 size;
#X msg 150 147 mode queue;
#X obj 192 205 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 25 44 The queue mode is a FIFO message storage (First In \,
First Out). A list input stores the elements sequenatially. A bang
otuputs the stored elements in order. The right outlet outputs the
size of the queue., f 63;
#X text 219 146 <= sets mode;
#X obj 164 270 print zl_queue;
#X connect 0 0 3 0;
#X connect 2 0 3 0;
#X connect 3 0 11 0;
#X connect 3 1 5 0;
#X connect 4 0 3 0;
#X connect 7 0 3 0;
#X connect 8 0 3 0;
#X restore 513 91 pd queue;
#N canvas 573 172 443 327 stack 0;
#X obj 121 183 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 28 15 comment 185 14 monaco ? 0 0 0 0 Mode: stack;
#X msg 128 122 zlclear;
#X msg 168 176 1 a 2 b 3 c;
#X obj 261 274 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 302 274 size;
#X obj 196 207 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 27 47 The stack mode is a LIFO message storage (Last In \,
First Out). A list input stores the elements sequenatially. A bang
otuputs the stored elements in order. The right outlet outputs the
size of the queue., f 63;
#X obj 168 238 cyclone/zl stack;
#X msg 154 149 mode stack;
#X text 227 148 <= sets mode;
#X obj 168 272 print zl_stack;
#X connect 0 0 8 0;
#X connect 2 0 8 0;
#X connect 3 0 8 0;
#X connect 6 0 8 0;
#X connect 8 0 11 0;
#X connect 8 1 4 0;
#X connect 9 0 8 0;
#X restore 513 258 pd stack;
#N canvas 840 133 464 326 stream 0;
#X obj 123 187 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 38 15 comment 185 14 monaco ? 0 0 0 0 Mode: stream;
#X obj 281 214 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X msg 130 126 zlclear;
#X obj 281 276 tgl 15 0 empty empty empty 17 7 0 10 -228856 -1 -1 1
1;
#X msg 156 153 mode stream -5;
#X text 252 153 <= set mode/argument;
#X obj 190 204 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 22 256;
#X obj 170 242 cyclone/zl stream 5;
#X text 37 43 the stream mode makes a list with the last N items. The
N is set as an argument or in the right inlet. A negative N inverts
the list. The right outlet sends "1" if it reached the N number of
elements and "0" otherwise. A bang resends the last output., f 62
;
#X obj 170 276 print zl_stream;
#X connect 0 0 8 0;
#X connect 2 0 8 1;
#X connect 3 0 8 0;
#X connect 5 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 10 0;
#X connect 8 1 4 0;
#X restore 513 279 pd stream;
#N canvas 804 199 422 308 sum 0;
#X obj 101 167 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 30 15 comment 185 14 monaco ? 0 0 0 0 Mode: sum;
#X msg 148 160 1 2 3 4 5 6 7 8 9 10;
#X obj 148 256 nbx 3 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X msg 108 106 zlclear;
#X obj 148 222 cyclone/zl sum;
#X msg 166 192 1 a 2 c;
#X msg 134 133 mode sum;
#X text 30 45 The mode sum sums the float values in a list \, symbol
elements are ignored. A bang performs the operation in the last received
list. Right inlet/outlet don't do anything.;
#X connect 0 0 5 0;
#X connect 2 0 5 0;
#X connect 4 0 5 0;
#X connect 5 0 3 0;
#X connect 6 0 5 0;
#X connect 7 0 5 0;
#X restore 513 324 pd sum;
#N canvas 818 151 405 322 unique 0;
#X obj 63 176 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 20 12 comment 185 14 monaco ? 0 0 0 0 Mode: unique;
#X text 248 139 <= sets mode and arguments, f 14;
#X msg 81 109 zlclear;
#X msg 265 212 truc 1;
#X msg 148 199 a b toto c titi;
#X text 21 39 unique removes items in a list \, the items to filter
are specified as the arguments or the right input. The right outlet
is inactive.;
#X msg 125 175 truc machin 2 3.4 1;
#X obj 106 242 cyclone/zl unique toto titi;
#X msg 106 139 mode unique toto titi;
#X obj 106 271 print zl_unique;
#X connect 0 0 8 0;
#X connect 3 0 8 0;
#X connect 4 0 8 1;
#X connect 5 0 8 0;
#X connect 7 0 8 0;
#X connect 8 0 10 0;
#X connect 9 0 8 0;
#X restore 467 416 pd unique;
#N canvas 804 199 422 308 thin 0;
#X obj 101 167 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 30 15 comment 185 14 monaco ? 0 0 0 0 Mode: thin;
#X msg 108 106 zlclear;
#X text 30 45 The thin mode remove all the duplicates from an input
list. A bang performs the operation in the last received list. Right
inlet/outlet don't do anything.;
#X msg 166 192 1 a 1 2 c 2;
#X obj 148 222 cyclone/zl thin;
#X msg 134 133 mode thin;
#X text 203 134 <= sets mode;
#X msg 148 160 a b e c e b b;
#X obj 148 250 print zl_thin;
#X connect 0 0 5 0;
#X connect 2 0 5 0;
#X connect 4 0 5 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 8 0 5 0;
#X restore 514 368 pd thin;
#N canvas 700 167 435 325 indexmap 0;
#X obj 57 190 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 34 13 comment 185 14 monaco ? 0 0 0 0 Mode: indexmap;
#X msg 64 139 zlclear;
#X msg 104 193 A B C D E F G H;
#X obj 104 279 print indexmap;
#X msg 251 214 0 0 1 0 3 2 5;
#X text 340 214 <= indexes;
#X text 33 41 In this mode \, a list of indexes (0-based) in the right
inlet or as arguments indicates the indexes to generate a new list
from the received list in the left inlet. An index less than 0 or greater
than/equal to the number of elements of the incoming list will be clamped
to 0 - a bang performs the operation in the last received list.;
#X obj 104 245 cyclone/zl indexmap 2 3 1;
#X msg 90 166 mode indexmap 4 5 3;
#X connect 0 0 8 0;
#X connect 2 0 8 0;
#X connect 3 0 8 0;
#X connect 5 0 8 1;
#X connect 8 0 4 0;
#X connect 9 0 8 0;
#X restore 430 216 pd indexmap;
#N canvas 601 172 441 297 swap 0;
#X obj 101 150 bng 18 250 50 0 empty empty empty 0 -6 0 8 -216373 -66577
-1;
#X obj 36 7 comment 185 14 monaco ? 0 0 0 0 Mode: swap;
#X msg 118 93 zlclear;
#X obj 144 233 print zl_swap;
#X msg 167 153 A B C D;
#X msg 144 120 mode swap 1 2 3 4;
#X msg 279 143 1 3 0 2;
#X obj 144 199 cyclone/zl swap 3 2 1 0;
#X msg 292 168 2 3;
#X text 35 35 The right inlet or argument is a list of pair of indexes
(0-based) to swap in the received list in the left inlet. A bang performs
the operation in the last received list., f 57;
#X text 332 142 <= indexes;
#X connect 0 0 7 0;
#X connect 2 0 7 0;
#X connect 4 0 7 0;
#X connect 5 0 7 0;
#X connect 6 0 7 1;
#X connect 7 0 3 0;
#X connect 8 0 7 1;
#X restore 514 346 pd swap;
#X connect 0 0 30 0;
#X connect 1 0 24 0;
#X connect 25 0 32 0;
#X connect 26 0 25 0;
#X connect 27 0 25 0;
#X connect 30 2 31 0;
#X connect 31 0 32 0;
#X connect 32 0 1 0;
#X restore 475 202 pd examples;
#X text 178 356 - output according to the mode: see details in [pd
examples];
#X text 178 375 - output according to the mode: see details in [pd
examples];
#X obj 166 127 bng 18 250 50 0 empty empty empty 17 7 0 10 -228856
-1 -1;
#X msg 247 153 zlclear;
#X text 114 126 resends;
#X text 117 141 length;
#X text 178 324 - depends on the mode \, see [pd examples];
#N canvas 430 180 512 447 subsequent_arguments 0;
#X text 44 127 group;
#X text 50 159 iter;
#X text 56 225 mth;
#X text 56 255 reg;
#X text 50 302 sect;
#X text 44 317 slice;
#X text 56 270 rot;
#X text 44 95 ecils;
#X text 56 240 nth;
#X text 83 225 - float: the element position counting from 0 (default
0), f 65;
#X text 83 255 - anything: stored elements (default none), f 65;
#X text 56 364 sub;
#X text 83 364 - anything: elements to look for (default none), f
65;
#X text 83 127 - float: length of the grouped list (default is zlmaxsize)
, f 65;
#X text 83 240 - float: the element position counting from 1 (default
0), f 65;
#X text 83 270 - float: number to rotate to (default 0), f 65;
#X text 83 317 - float: position to slice the list (default 0), f
65;
#X text 83 95 - float: position to slice the list (default 0), f 65
;
#X text 83 159 - float: length of output list (default 0), f 65;
#X text 44 397 union;
#X text 83 397 - anything: elements to union to the first list (default
none), f 65;
#X text 50 175 join;
#X text 83 175 - anything: elements to join to the first list (default
none), f 65;
#X text 50 333 sort;
#X text 83 333 - float: order "-1" is desending \, ascending otherwise
(default 0), f 65;
#X text 32 78 compare;
#X text 83 302 - anything: list to compare with left input (default
none), f 65;
#X text 83 78 - anything: list to compare with left input (default
none), f 65;
#X text 38 111 filter;
#X text 50 192 lace;
#X text 38 209 lookup;
#X text 26 286 scramble;
#X text 83 286 - anything: list to be scrambled (default none), f
65;
#X text 83 192 - anything: 2nd list to be interleaved (default none)
, f 65;
#X text 83 209 - anything: list to be looked up (default none), f
65;
#X text 83 111 - anything: elements to filter (default none), f 65
;
#X text 76 18 The modes: change \, delace \, len \, median \, queue
\, rev \, stack \, sum thin don't have arguments. The other modes can
have subsequent arguments as below. See also [pd examples] for more
details on how they work., f 63;
#X text 38 414 unique;
#X text 50 380 swap;
#X text 38 348 stream;
#X text 26 143 indexmap;
#X text 83 143 - anything: list to be remaped (default none), f 65
;
#X text 83 348 - float: N elements to stream (default 0), f 65;
#X text 83 414 - anything: list of elements to "uniqued" (default none)
, f 65;
#X text 83 380 - anything: list to be swapped (default none), f 65
;
#X restore 299 471 pd subsequent_arguments;
#X text 178 264 -;
#X text 190 263 sets mode (you can also set subsequent arguments) -
check [pd examples] for more info;
#X text 70 85 [zl] processes messages with one or more elements ("list
messages' or "anything") according to a mode (set via argument/message).
, f 66;
#X obj 17 57 cyclone/comment 0 18 times ? 0 0 0 0 List processor;
#X obj 16 4 cyclone/comment 0 37 times ? 0 0 0 0 zl;
#X obj 322 28 cyclone/comment 0 13 courier ? 0 224 228 220 Objects
cloned from Max/MSP;
#X obj 363 4 cyclone/comment 0 24 courier ? 0 224 228 220 cyclone;
#X text 178 306 - sets maximum list size (from 1 to 32767);
#X text 234 205 <= number of elements in a message;
#X text 293 181 length mode;
#X text 184 405 optional: maximum list size (1 - 32767 \, default 256)
, f 60;
#X text 129 502 @zlmaxsize <float> - max list size (1 - 32767 \, default
256), f 62;
#X text 178 291 - clears mode's arguments and received data in both
inlets;
#X obj 199 129 nbx 2 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 0 256;
#X text 178 234 - mode dependant operation on current data see [pd
examples];
#X text 298 153 clears loaded data;
#X obj 176 205 bng 15 250 50 0 empty empty empty 17 7 0 10 -228856
-1 -1;
#X text 184 421 mode (change \, compare \, delace \, ecils \, group
\, indexmap \, iter \, join \, lace \, len \, lookup \, median \, mth
\, nth \, queue \, reg \, rev \, rot \, sect \, scramble \, slice \,
sort \, stack \, stream \, sub \, sum \, swap \, thin \, union or unique).
Modes can have subsequent arguments \, check:;
#X connect 10 0 6 0;
#X connect 10 0 54 0;
#X connect 26 0 10 0;
#X connect 32 0 10 0;
#X connect 33 0 10 0;
#X connect 51 0 10 0;
